==========
八皇后问题
==========

:date: 2015-03-06
:slug: eight-queens-problem


八皇后问题不算太难，可写起来也是挺麻烦的。有家奇怪的公司为了炒作，提出了C++在十行之内解八皇后的挑战，尽管他们自己办不到。

.. more


这当然也是可以做到啦，查查标准库文档一会儿就写出来了。


.. code:: c++

    #include <iostream>
    #include <algorithm>
    #include <bitset>
    #include <numeric>
    #include <utility>
    int main() {
      for (int queens[] = {0,1,2,3,4,5,6,7}; ::std::next_permutation(queens,queens+8); )
        if ((::std::bitset<15>(::std::accumulate(queens,queens+8, ::std::make_pair(0, 0), [](::std::pair<int, int> a, int b){return ::std::make_pair((1<<(b+a.second))|a.first,a.second+1);}).first).count() == 8) && (::std::bitset<15>(::std::accumulate(queens, queens+8, ::std::make_pair(0, 0), [](::std::pair<int, int> a, int b){return ::std::make_pair((1<<(7+b-a.second))|a.first, a.second+1);}).first).count() == 8))
          ::std::cout << queens[0] << queens[1] << queens[2] << queens[3] << queens[4] << queens[5] << queens[6] << queens[7] << ::std::endl;
    }


可是要代码短，还是得用J语言啊。下面的解法很直观，很占内存，可也是很短的。

.. code::

       NB. 分解成两个问题
       NB. 1) 生成全排列，这样每条横线，每条竖线上都只有一个皇后
       NB. 2) 检查每条斜线上是否最多只有一个皇后
    
       NB. 生成全排列很简单
       (i.!3)A.i.3
    0 1 2
    0 2 1
    1 0 2
    1 2 0
    2 0 1
    2 1 0
       NB. 0表示空，1表示皇后
       #:2^(i.!3)A.i.3
    0 0 1
    0 1 0
    1 0 0
    
    0 0 1
    1 0 0
    0 1 0
    
    0 1 0
    0 0 1
    1 0 0
    
    0 1 0
    1 0 0
    0 0 1
    
    1 0 0
    0 0 1
    0 1 0
    
    1 0 0
    0 1 0
    0 0 1
    
       NB. 沿从右上往左下的斜线相加
       +//."2 #:2^(i.!3)A.i.3
    0 0 3 0 0
    0 1 1 1 0
    0 1 1 1 0
    0 2 0 0 1
    1 0 0 2 0
    1 0 1 0 1
    
       NB. 判断是否大于1
       1 < +//."2 #:2^(i.!3)A.i.3
    0 0 1 0 0
    0 0 0 0 0
    0 0 0 0 0
    0 1 0 0 0
    0 0 0 1 0
    0 0 0 0 0
    
       NB. 因为是从上到下算下去的，得转一下
       |: 1 < +//."2 #:2^(i.!3)A.i.3
    0 0 0 0 0 0
    0 0 0 1 0 0
    1 0 0 0 0 0
    0 0 0 0 1 0
    0 0 0 0 0 0
    
       NB. 按竖行分别取或
       +./ |: 1 < +//."2 #:2^(i.!3)A.i.3
    1 0 0 1 1 0
    
       NB. 取反
       -. +./ |: 1 < +//."2 #:2^(i.!3)A.i.3
    0 1 1 0 0 1
    
       NB. 定义d，是否在从右上往左下的斜线上皇后数小于等于1
       d=:3 :'-.+./|:1<+//."2 y'
       d #:2^(i.!3)A.i.3
    0 1 1 0 0 1
    
       NB. 取出对应的矩阵
       (d#]) #:2^(i.!3)A.i.3
    0 0 1
    1 0 0
    0 1 0
    
    0 1 0
    0 0 1
    1 0 0
    
    1 0 0
    0 1 0
    0 0 1
    
       NB. 把矩阵沿竖直方向翻转，这样找出左上往右下的斜线上皇后数小于等于1的
       (|.@d#]) #:2^(i.!3)A.i.3
    0 0 1
    0 1 0
    1 0 0
    
    0 1 0
    1 0 0
    0 0 1
    
    1 0 0
    0 0 1
    0 1 0
    
       NB. 定义q，用来找出所有N皇后矩阵
       q=:3 :'((d*.|.@d)#])#:2^(i.!y)A.i.y'
       # q 8
    92
       q 4
    0 0 1 0
    1 0 0 0
    0 0 0 1
    0 1 0 0
    
    0 1 0 0
    0 0 0 1
    1 0 0 0
    0 0 1 0
       q 6
    0 0 0 0 1 0
    0 0 1 0 0 0
    1 0 0 0 0 0
    0 0 0 0 0 1
    0 0 0 1 0 0
    0 1 0 0 0 0
    
    0 0 0 1 0 0
    1 0 0 0 0 0
    0 0 0 0 1 0
    0 1 0 0 0 0
    0 0 0 0 0 1
    0 0 1 0 0 0
    
    0 0 1 0 0 0
    0 0 0 0 0 1
    0 1 0 0 0 0
    0 0 0 0 1 0
    1 0 0 0 0 0
    0 0 0 1 0 0
    
    0 1 0 0 0 0
    0 0 0 1 0 0
    0 0 0 0 0 1
    1 0 0 0 0 0
    0 0 1 0 0 0
    0 0 0 0 1 0
    
       NB. 太棒了，不到80个字符就已经能解出八皇后问题了
       d=:3 :'-.+./|:1<+//."2 y'
       q=:3 :'((d*.|.@d)#])#:2^(i.!y)A.i.y'



用和上面C++相同的算法，在J语言里可以这么写

.. code::

   (i.(([:*./"1[:(#=+/@:~:)"1(+,:-)"1)#])i.@:!A.i.)8

